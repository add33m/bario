<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
  </head>

  <body>
    <script src="simple.js">
      /*
        Course builder for Bario by add33m (github.com/add33m/bario)
      */
      
      // ASSETS:
      // Define and preload textures
      const bricksUrl = new Image();
      bricksUrl.src = "https://cdn.discordapp.com/attachments/489085929726935041/617048046299119831/block-16.gif";
      const blockUrl = new Image();
      blockUrl.src = "https://cdn.discordapp.com/attachments/489085929726935041/617048181439463455/block-1.gif";
      const grassUrl = new Image();
      grassUrl.src = "https://cdn.discordapp.com/attachments/489085929726935041/616702235484618754/flatgrass.png";
      const qmarkUrl = new Image();
      qmarkUrl.src = "https://cdn.discordapp.com/attachments/489085929726935041/617123384593088516/block-193.gif";
      const qmarkUsedUrl = new Image();
      qmarkUsedUrl.src = "https://cdn.discordapp.com/attachments/489085929726935041/617130212869799993/block-192.gif";
      const playerSpriteSheet = new Image();
      playerSpriteSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/617650288408395776/SMBPlayerSprites.png";
      const playerSpriteSheetReversed = new Image();
      playerSpriteSheetReversed.src = "https://cdn.discordapp.com/attachments/489085929726935041/617651006263656451/SMBPlayerSpritesReversed.png";
      const enemySpriteSheet = new Image();
      enemySpriteSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/617817625778454537/SMBEnemySprites.png";
      const objectSpriteSheet = new Image();
      objectSpriteSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/618484986642825217/SMBObjectSprites.png";
      const gameTileSheet = new Image();
      gameTileSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/617422854409158676/SMBTileset.png";


      // Map stuff
      let mapArray = [];
      const blockSize = 32;
      let canvasPos = 0;

      // What block is currently selected
      let selected = "block";

      // Scaling (20 blocks tall)
      const scale_factor = blockSize * 20 / totalHeight;
      scale(1 / scale_factor,1 / scale_factor);

      // Context (get canvas)
      let canvas = document.getElementById("canvas");
      let context = canvas.getContext("2d");
      context.imageSmoothingEnabled = false;
      updatesPerSecond = 30;

      // Draw a static image
      function drawImg(image,x,y) {
        context.drawImage(image,0,0,blockSize,blockSize,x * blockSize,totalHeight * scale_factor - y * blockSize,blockSize,blockSize)
      }

      // Draw an animated image. Frames are stacked next to each other (top = first frame) and equal in size
      function drawAnimImg(image,totalFrames,speed,x,y,x0=0,y0=0,xs=blockSize,ys=blockSize,xf=blockSize,yf=blockSize,xoffset=1,yoffset=0) { // Speed should never exceed 2, or it will skip frames
        // Find the frame based on the time, by rounding it down and then dividing it, taking the remainder as the frame
        // 0 = start position of animation, s = size of the animation frame, offset = the offset per frame, f = final drawn resolution
        let frame = Math.floor(performance.now() * speed / 100) % totalFrames;
        context.drawImage(image,xoffset * (frame + 1) + x0 + frame * xs,yoffset * (frame + 1) + y0,xs,ys,x,y,xf,yf)
      }

      // Draws a transition image, like drawAnimImg but flips between two images instead of two frames. Array: [image,x,y,x0=0,y0=0,xs=blockSize,ys=blockSize,xf=blockSize,yf=blockSize]
      function drawTransAnim(imageArray=[],speed) {
        let totalFrames = imageArray.length;
        let frame = Math.floor(performance.now() * speed / 100) % totalFrames;
        let currImage = imageArray[frame];

        context.drawImage(currImage[0],xoffset * (frame + 1) + currImage[3] + frame * currImage[5],yoffset * (frame + 1) + currImage[4],currImage[5],currImage[6],currImage[1],currImage[2],currImage[7],currImage[8])
      }

      // Draw out the map
      function drawMap() {

        // Draw background
        rectangle(canvasPos,0,totalWidth * scale_factor,totalHeight * scale_factor,"#93bbec");

        // Find middle point on screen
        let screen_mid = canvasPos + totalWidth * scale_factor / 2

        // Draw grid lines
        let screenBlockWidth = totalWidth * scale_factor / blockSize + 2;
        let screenBlockHeight = 22;

        // Draw vertical lines
        for (let i = 0; i < screenBlockWidth; i++) {
          line((i-1)*32,0,(i-1)*32,totalHeight * scale_factor,1,"grey");
        }

        // Draw vertical lines
        for (let i = 0; i < screenBlockHeight; i++) {
          line(0,(i-1)*32,totalWidth * scale_factor,(i-1)*32,1,"grey");
        }

        // Go through every block
        for (let i = 0; i < mapArray.length; i++) {
          // Find block type
          let type = mapArray[i][2]

          // Draw if not an invisible block
          if (type != "inv") {

            // Draw the image with the right texture, and animated if should be
            if (type == "grass") {
              drawImg(grassUrl,mapArray[i][0],mapArray[i][1]);
            } else if (type == "bricks") {
              drawAnimImg(gameTileSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,0,221,16,16,32,32,1,1);
            } else if (type == "block") {
              drawAnimImg(gameTileSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,102,0,16,16,32,32,1,1);
            } else if (type == "flagpole") {
              drawAnimImg(objectSpriteSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize - 288,765,452,16,160,32,320);
              drawAnimImg(objectSpriteSheet,1,1,(mapArray[i][0]) * blockSize - 18,totalHeight * scale_factor - mapArray[i][1] * blockSize - flagPos,765,435,16,16,32,32);
            } else if (type == "coin_block") {
              drawAnimImg(qmarkUrl,1,.4,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize);
            } else if (type == "used_block") {
              drawImg(qmarkUsedUrl,mapArray[i][0],mapArray[i][1]);
            } else if (type == "goomba" && abs(mapArray[i][0] * blockSize - screen_mid) < totalWidth * scale_factor && ! mapArray[i][3]) {
              // If close enough, spawn a goomba
              iEntities.push(new IEntity("goomba",mapArray[i][0],mapArray[i][1]))
              mapArray[i][3] = true;
            }
          }
        }
      }

      // On every frame/tick, check what block is currently selected, and if clicked on a block then place that into the map array
      function update() {
        // First clear the canvas from the previous frame
        clearScreen();

        // Check for any keyboard input to see what block should be selected

        // If clicking, check what block is clicked on
        if (mouse.left) {
          let mouseXblock = floor(mouse.x * scale_factor / blockSize);
          let mouseYblock = ceil((totalHeight - mouse.y) * scale_factor / blockSize);

          let block = [mouseXblock,mouseYblock,selected];

          if (!mapArray.includes(block)) {
            mapArray.push(block);
          }
        // Removing blocks if right clicked on
        } else if (mouse.right) {
          let mouseXblock = floor(mouse.x * scale_factor / blockSize);
          let mouseYblock = ceil((totalHeight - mouse.y) * scale_factor / blockSize);

          let block = [mouseXblock,mouseYblock,selected];

          if (mapArray.includes(block)) {
            mapArray.splice(mapArray.indexOf(block),1);
          }
        }

        // Finally draw the map
        drawMap();
      }

    </script>
  </body>
</html>