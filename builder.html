<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Bario builder by add33m</title>
    <link rel="icon" href="buildericon.ico">
  </head>

  <body>
    <script src="simple.js">
      /*
        Course builder for Bario by add33m (github.com/add33m/bario)
      */
      
      // ASSETS:
      // Define and preload textures
      const bricksUrl = new Image();
      bricksUrl.src = "https://cdn.discordapp.com/attachments/489085929726935041/617048046299119831/block-16.gif";
      const blockUrl = new Image();
      blockUrl.src = "https://cdn.discordapp.com/attachments/489085929726935041/617048181439463455/block-1.gif";
      const grassUrl = new Image();
      grassUrl.src = "https://cdn.discordapp.com/attachments/489085929726935041/616702235484618754/flatgrass.png";
      const qmarkUrl = new Image();
      qmarkUrl.src = "https://cdn.discordapp.com/attachments/489085929726935041/617123384593088516/block-193.gif";
      const qmarkUsedUrl = new Image();
      qmarkUsedUrl.src = "https://cdn.discordapp.com/attachments/489085929726935041/617130212869799993/block-192.gif";
      const playerSpriteSheet = new Image();
      playerSpriteSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/617650288408395776/SMBPlayerSprites.png";
      const playerSpriteSheetReversed = new Image();
      playerSpriteSheetReversed.src = "https://cdn.discordapp.com/attachments/489085929726935041/617651006263656451/SMBPlayerSpritesReversed.png";
      const enemySpriteSheet = new Image();
      enemySpriteSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/617817625778454537/SMBEnemySprites.png";
      const objectSpriteSheet = new Image();
      objectSpriteSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/618484986642825217/SMBObjectSprites.png";
      const gameTileSheet = new Image();
      gameTileSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/617422854409158676/SMBTileset.png";


      // Map stuff
      let mapArray = [];
      const blockSize = 32;
      let canvasPos = 0;
      updatesPerSecond = 60;

      // Look if a map is locally saved, and use that if so is the case
      let savedMap = localStorage.getItem("currentBuiltMap");
      if (savedMap) {
        mapArray = JSON.parse(savedMap);
      }

      // What block is currently selected
      let selected = "bricks";
      // Blocktypes: "bricks", "block", "flagpole", "goomba"

      // Scaling (20 blocks tall)
      const scale_factor = blockSize * 20 / totalHeight;
      scale(1 / scale_factor,1 / scale_factor);

      // Context (get canvas)
      let canvas = document.getElementById("canvas");
      let context = canvas.getContext("2d");
      context.imageSmoothingEnabled = false;
      updatesPerSecond = 30;

      // Draw a static image
      function drawImg(image,x,y) {
        context.drawImage(image,0,0,blockSize,blockSize,x * blockSize,totalHeight * scale_factor - y * blockSize,blockSize,blockSize)
      }

      // Draw an animated image. Frames are stacked next to each other (top = first frame) and equal in size
      function drawAnimImg(image,totalFrames,speed,x,y,x0=0,y0=0,xs=blockSize,ys=blockSize,xf=blockSize,yf=blockSize,xoffset=1,yoffset=0) { // Speed should never exceed 2, or it will skip frames
        // Find the frame based on the time, by rounding it down and then dividing it, taking the remainder as the frame
        // 0 = start position of animation, s = size of the animation frame, offset = the offset per frame, f = final drawn resolution
        let frame = Math.floor(performance.now() * speed / 100) % totalFrames;
        context.drawImage(image,xoffset * (frame + 1) + x0 + frame * xs,yoffset * (frame + 1) + y0,xs,ys,x,y,xf,yf)
      }

      // Draws a transition image, like drawAnimImg but flips between two images instead of two frames. Array: [image,x,y,x0=0,y0=0,xs=blockSize,ys=blockSize,xf=blockSize,yf=blockSize]
      function drawTransAnim(imageArray=[],speed) {
        let totalFrames = imageArray.length;
        let frame = Math.floor(performance.now() * speed / 100) % totalFrames;
        let currImage = imageArray[frame];

        context.drawImage(currImage[0],xoffset * (frame + 1) + currImage[3] + frame * currImage[5],yoffset * (frame + 1) + currImage[4],currImage[5],currImage[6],currImage[1],currImage[2],currImage[7],currImage[8])
      }

      // Draw out the map
      function drawMap() {

        // Draw background
        rectangle(-canvasPos,0,totalWidth * scale_factor,totalHeight * scale_factor,"#93bbec");

        // Find middle point on screen
        let screen_mid = canvasPos + totalWidth * scale_factor / 2

        // Draw grid lines
        let screenBlockWidth = totalWidth * scale_factor / blockSize + 2;
        let screenBlockHeight = 22;

        // Draw vertical lines
        for (let i = floor(-canvasPos / 32); i < screenBlockWidth + floor(-canvasPos / 32); i++) {
          line((i-1)*32,0,(i-1)*32,totalHeight * scale_factor,1,"grey");
        }

        // Draw horizontal lines
        for (let i = 0; i < screenBlockHeight; i++) {
          line(-canvasPos,(i-1)*32,totalWidth * scale_factor-canvasPos,(i-1)*32,1,"grey");
        }

        // Go through every block
        for (let i = 0; i < mapArray.length; i++) {
          // Find block type
          let type = mapArray[i][2]

          // Draw if not an invisible block
          if (type != "inv") {

            // Draw the image with the right texture, and animated if should be
            if (type == "grass") {
              drawImg(grassUrl,mapArray[i][0],mapArray[i][1]);
            } else if (type == "bricks") {
              drawAnimImg(gameTileSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,0,221,16,16,32,32,1,1);
            } else if (type == "block") {
              drawAnimImg(gameTileSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,102,0,16,16,32,32,1,1);
            } else if (type == "flagpole") {
              drawAnimImg(objectSpriteSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize - 288,765,452,16,160,32,320);
              drawAnimImg(objectSpriteSheet,1,1,(mapArray[i][0]) * blockSize - 18,totalHeight * scale_factor - mapArray[i][1] * blockSize - blockSize * 8,765,435,16,16,32,32);
            } else if (type == "coin_block") {
              drawAnimImg(qmarkUrl,1,.4,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize);
            } else if (type == "used_block") {
              drawImg(qmarkUsedUrl,mapArray[i][0],mapArray[i][1]);
            } else if (type == "goomba") {
              drawAnimImg(enemySpriteSheet,2,.4,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,0,1,16,16,32,32);
            }
          }
        }
      }

      // Made to see if there is a block in the map that has the properties of the block sought after. Made for checking if to remove blocks
      function lookForBlockInMap(x,y) {
        for (let i=0; i<mapArray.length; i++) {
          if (mapArray[i][0] == x && mapArray[i][1] == y) {
            // Return i+1 so that the first block (index 0) won't count as non-existent
            return i+1;
          }
        }
      }

      // If window is getting unloaded, save map progress
      window.onbeforeunload = function(){
        localStorage.setItem("currentBuiltMap",JSON.stringify(mapArray))
      };

      // If pressing N to reset the map
      window.onkeypress = function(){
        if (event.keyCode === 110) {
          let response = prompt("Are you sure you want to clear the map? \n(Type 'yes' to proceed)");
          if (response == "yes") {
            mapArray = [];
          }
        }
      };

      // On every frame/tick, check what block is currently selected, and if clicked on a block then place that into the map array
      function update() {
        // First clear the canvas from the previous frame
        clearScreen();

        // Move the canvas
        if (keyboard.right && keyboard.shift) {
          canvasPos -= 16;
          translate(-16,0)
        } else if (keyboard.right) {
          canvasPos -= 8;
          translate(-8,0)
        }
        if (keyboard.left && keyboard.shift) {
          if (canvasPos < -8) {
            canvasPos += 16;
            translate(16,0);
          } else if (canvasPos < 0) {
            canvasPos += 8;
            translate(8,0);
          }
        } else if (keyboard.left) {
          if (canvasPos < 0) {
            canvasPos += 8;
            translate(8,0);
          } 
        } 
        
        // Select the right block
        if (keyboard.one) {
          selected = "bricks";
        } else if (keyboard.two) {
          selected = "block";
        } else if (keyboard.three) {
          selected = "flagpole";
        } else if (keyboard.four) {
          selected = "goomba";
        }

        // If clicking, check what block is clicked on
        if (mouse.left) {
          let mouseXblock = floor((mouse.x * scale_factor -canvasPos) / blockSize);
          let mouseYblock = ceil((totalHeight - mouse.y) * scale_factor / blockSize);

          let blockIndex = lookForBlockInMap(mouseXblock,mouseYblock);

          if (! blockIndex) {
            mapArray.push([mouseXblock,mouseYblock,selected]);
          }
        
        // Removing blocks if right clicked on
        } else if (mouse.right) {
          let mouseXblock = floor((mouse.x * scale_factor -canvasPos) / blockSize);
          let mouseYblock = ceil((totalHeight - mouse.y) * scale_factor / blockSize);

          let blockIndex = lookForBlockInMap(mouseXblock,mouseYblock);

          if (blockIndex) {
            // Counter the i+1
            mapArray.splice(blockIndex-1,1);
          }
        }

        // See if hitting enter to try out the course
        if (keyboard.enter) {
          // b
        }

        // Finally draw the map
        drawMap();
      }

    </script>
  </body>
</html>