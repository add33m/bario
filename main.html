<meta charset="UTF-8">
<script src="https://koda.nu/simple.js">

  // Map array
  const mapArray = [[0,1,"bricks"],[1,1,"bricks"],[2,1,"bricks"],[2,2,"block"],[3,1,"bricks"],[4,1,"bricks"],[5,1,"bricks"],[6,1,"bricks"],[7,1,"bricks"],[8,1,"bricks"]];
  const blockSize = 32;
  
  // Scaling (10 blocks tall)
  const scale_factor = blockSize * 20 / totalHeight;
  scale(1 / scale_factor,1 / scale_factor);
  
  // ASSETS:
  // Textures
  const bricksUrl = "https://cdn.discordapp.com/attachments/489085929726935041/617048046299119831/block-16.gif";
  const blockUrl = "https://cdn.discordapp.com/attachments/489085929726935041/617048181439463455/block-1.gif";
  const grassUrl = "https://cdn.discordapp.com/attachments/489085929726935041/616702235484618754/flatgrass.png";
  const mario1Url = "https://cdn.discordapp.com/attachments/489085929726935041/617048861416095750/mario1.png";
  // Sounds
  const deathUrl = "https://cdn.discordapp.com/attachments/489085929726935041/616335506216583217/smb_mariodie.wav";
  const jumpUrl = "https://cdn.discordapp.com/attachments/489085929726935041/616353716068548697/smb_jumpsmall.wav";

  // Preload sounds
  preloadSound(deathUrl);
  preloadSound(jumpUrl);

  // Global variables
  const gravity = 1;
  
  class Player {
    constructor(respawnX, respawnY) {
      // Set up variables and constants of the player and Player class
      this.respawnX = respawnX;
      this.respawnY = respawnY;
      this.x = this.respawnX * blockSize;
      this.y = totalHeight * scale_factor - this.respawnY * blockSize;
      this.xv = 0;
      this.yv = 0;
      this.touching_ground = false;
      this.state = 1;
      this.debug = false;
      this.width = blockSize;
      this.height = blockSize;
      this.friction = 1.4;
    }
    
    // Function that checks if any block is within range to collide
    checkCollision() {
      
      // Call off the collision detection if not alive
      if (this.state < 1) {return null}
      
      // Set char to be in the air so if it isn't on the ground he can't air jump
      this.touching_ground = false;

      // For every block
      for (var i = 0; i < mapArray.length; i++) {
        var dx = abs(this.x + this.width / 2 - (mapArray[i][0] * blockSize + blockSize / 2));
        var dy = abs(this.y + this.height / 2 - (totalHeight * scale_factor - mapArray[i][1] * blockSize + blockSize / 2));

        // If in range
        if (dy < this.height/2 + blockSize*2 && dx < this.width/2 + blockSize*2)
        {
          // Perform collision
          this.collide({x: mapArray[i][0]*blockSize, y: totalHeight * scale_factor - mapArray[i][1]*blockSize, width: blockSize, height: blockSize});
        }
      }
    }

    collide(object) {
      // Calculate distance to object for this and next tick
      var dxv = abs((this.x + this.xv + this.width/2) - (object.x + object.width/2));
      var dyv = abs((this.y + this.yv + this.height/2) - (object.y + object.height/2));
      var dx = abs((this.x + this.width/2) - (object.x + object.width/2));
      var dy = abs((this.y + this.height/2) - (object.y + object.height/2));

      // Debug line indicating what blocks are being calculated for collision
      if (this.debug) {
        line(this.x + this.xv + this.width/2, this.y + this.yv + this.height/2, object.x + object.width/2, object.y + object.height/2, "black");
      }

      // Check if character will be inside object next tick
      if (dyv < this.height/2 + object.height/2 && dxv < this.width/2 + object.width/2) {
        
        // Check if the object is coming in the x axis
        if (dx * (this.height / 2 + object.height / 2) >= dy * (this.width / 2 + object.width / 2)) {

          // Change the velocity so the character intersects the border of the block next tick 
          if (this.x - object.x > 0) {
            // From the left
            this.xv = -(dx - this.width/2 - object.width/2);
          } else {
            // From the right
            this.xv = dx - this.width/2 - object.width/2;
          }
        }
        // If not coming in the x axis, the object is coming in the y axis
        else {

          // Change the velocity so the character intersects the border of the block next tick 
          if (this.y - object.y < 0) {
            // From the top
            this.yv = dy - this.height/2 - object.height/2;
            this.touching_ground = true;            
          } else {
            // From the bottom
            this.yv = -(dy - this.height/2 - object.height/2);
          }
        }
      }
    }

    // Draw the player
    draw() {

      // Set player texture url depending on player state
      var url;
      if (this.state == 1 || this.state == 0) {
        url = mario1Url;
      }

      picture(this.x,this.y,url);
    }

    // Apply gravity and input forces to player velocity, and check for death
    apply_forces() {

      // If not on the ground, add gravity
      if (! this.touching_ground) {
        this.yv += gravity
      }
      
      // If below y=0 and not already dead, kill the player and respawn
      if (this.y > totalHeight * scale_factor && this.state != 0) {
        playSound(deathUrl);
        this.state = 0;
        this.yv = -15;
        this.xv = 20;

        // Respawn after the sound/animation is done
        window.setTimeout(function(){this.respawn(this)}, 3200);
      }

      // Add sidewards movement and friction if no sideways key is being held down
      if (keyboard["d"] && this.state > 0) {
        // Left
        this.xv = 6;
      } else if (keyboard["a"] && this.state > 0) {
        // Right
        this.xv = -6;
      } else {
        // Slow down movement using friction
        if (abs(this.xv) < .5) {this.xv = 0}
        this.xv = this.xv / this.friction
      }

      // Jump
      if (keyboard["w"] && this.touching_ground && this.state > 0) {
        this.yv = -20;
        playSound(jumpUrl, .4);
      }
    }

    // Apply player velocity to player position
    update_position() {
      this.x += this.xv;
      this.y += this.yv;
    }

    respawn(player) {
      // Set state to alive
      player.state = 1;

      // Reset positions to current starting position
      player.x = player.respawnX * blockSize;
      player.y = totalHeight * scale_factor - player.respawnY * blockSize
      player.xv = 0;
      player.yv = 0;
    }
  }
  
  
  // Create player
  let player1 = new Player(0,6);

  
  function drawMap() {
  	// Go through every block
    for (var i = 0; i < mapArray.length; i++) {

      // Set the picture's url based on 
      var url;
      if (mapArray[i][2] == "grass") {
        url = grassUrl;      
      }else if (mapArray[i][2] == "bricks") {
        url = bricksUrl;
      }else if (mapArray[i][2] == "block") {
        url = blockUrl;
      }

      picture(mapArray[i][0] * blockSize, totalHeight * scale_factor - blockSize * mapArray[i][1],url);
    }
  }
  

  // Every game update, perform a tick and render
  function update() {
    clearScreen();
    drawMap();
    player1.apply_forces();
    player1.checkCollision();
    player1.update_position();
    player1.draw();
  }
  

</script>