<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <title>Bario by add33m</title>
  <link rel="icon" href="barioicon.ico">
</head>

<body>
  <script src="simple.js">

    /*
      Made by add33m with (a bunch of) help from pelp3!
      **pelp3Ngine 2.3**
    */

    // Map
    let savedMapArray = [[-1,2,"inv"],[-1,3,"inv"],[-1,4,"inv"],[-1,5,"inv"],[-1,6,"inv"],[-1,7,"inv"],[-1,8,"inv"],[-1,9,"inv"],[-1,10,"inv"],[-1,11,"inv"],[0,1,"bricks"],[1,1,"bricks"],[2,1,"bricks"],[2,5,"mushroom_block"],[3,1,"bricks"],[4,1,"bricks"],[4,2,"block"],[5,1,"bricks"],[5,2,"goomba"],[6,2,"goomba"],[7,6,"block"],[6,1,"bricks"],[7,1,"bricks"],[8,1,"bricks"],[9,1,"bricks"],[7,2,"block"],[11,3,"flagpole"],[11,2,"block"],[10,1,"bricks"],[11,1,"bricks"],[12,1,"bricks"],[13,1,"bricks"],[14,1,"bricks"],[15,1,"bricks"],[16,2,"inv"]];
    const blockSize = 32;
    const resetMapOnRespawn = true;

    // Look for the current global/saved state of the game
    let globalGameState = localStorage.getItem("currentGameState");
    if (globalGameState) {
      globalGameState = JSON.parse(globalGameState);
    }

    // Look if a map is locally saved, and use that if supposed to
    let savedMap = localStorage.getItem("currentBuiltMap");
    if (savedMap && globalGameState.playingSavedMap) {
      savedMapArray = JSON.parse(savedMap);
      savedMapArray.unshift([-1,2,"inv"],[-1,3,"inv"],[-1,4,"inv"],[-1,5,"inv"],[-1,6,"inv"],[-1,7,"inv"],[-1,8,"inv"],[-1,9,"inv"],[-1,10,"inv"],[-1,11,"inv"]);
    }

    // Look if a map is requested to be played via the course viewer and use that if supposed to
    let mapToPlay = localStorage.getItem("mapToPlay");
    if (mapToPlay && globalGameState.playingOnlineMap) {
      savedMapArray = JSON.parse(mapToPlay);
      savedMapArray.unshift([-1,2,"inv"],[-1,3,"inv"],[-1,4,"inv"],[-1,5,"inv"],[-1,6,"inv"],[-1,7,"inv"],[-1,8,"inv"],[-1,9,"inv"],[-1,10,"inv"],[-1,11,"inv"]);
    }

    // If window is getting unloaded or leaving, save game state
    window.onbeforeunload = function(){
      localStorage.setItem("currentGameState",JSON.stringify(globalGameState));
    };

    let mapArray = JSON.parse(JSON.stringify(savedMapArray));

    // Scaling (14 blocks tall)
    const scale_factor = blockSize * 14 / totalHeight;
    scale(1 / scale_factor,1 / scale_factor);

    // Character selection
    let gameState = 0;
    let flagpolePosX;
    let flagPos = blockSize * 8;

    for (let i = 0; i < mapArray.length; i++) {
      if (mapArray[i][2] == "flagpole") {
        flagpolePosX = mapArray[i][0] * blockSize;
      }
    }

    // Reserve var for player
    let player1;

    // Pause physics when giving player a power up
    let activatePhysics = true;

    // Clears console to prevent memory usage and lag
    if (false) {
      window.setInterval(function(){
        console.clear()
      },10000)
    }
    
    // Canvas moving
    let canvasPosX = 0;
    let canvasPosY = 0;
    
    // ASSETS:
    // Define and preload textures
    const playerSpriteSheet = new Image();
    playerSpriteSheet.src = "SMBPlayerSprites.png";
    const playerSpriteSheetReversed = new Image();
    playerSpriteSheetReversed.src = "SMBPlayerSpritesReversed.png";
    const enemySpriteSheet = new Image();
    enemySpriteSheet.src = "SMBEnemySprites.png";
    const enemySpriteSheetReversed = new Image();
    enemySpriteSheetReversed.src = "SMBEnemySpritesReversed.png";
    const objectSpriteSheet = new Image();
    objectSpriteSheet.src = "SMBObjectSprites.png";
    const gameTileSheet = new Image();
    gameTileSheet.src = "SMBTileset.png";

    // Sounds
    const deathUrl = "https://cdn.discordapp.com/attachments/489085929726935041/616335506216583217/smb_mariodie.wav";
    const jumpUrl = "https://cdn.discordapp.com/attachments/489085929726935041/616353716068548697/smb_jumpsmall.wav";
    const coinUrl = "https://cdn.discordapp.com/attachments/489085929726935041/617145664618496016/smb_coin.wav";
    const stompUrl = "https://cdn.discordapp.com/attachments/489085929726935041/617815051428036608/smb_stomp.wav";
    const winUrl = "https://cdn.discordapp.com/attachments/489085929726935041/619212400532652068/smb_win.mp3";
    const flagpoleUrl = "https://cdn.discordapp.com/attachments/489085929726935041/619967226564313088/smb_flagpole.wav";
    const musicUrl = "main-theme-overworld.mp3";

    // Preload sounds
    preloadSound(deathUrl);
    preloadSound(jumpUrl);
    preloadSound(coinUrl);
    preloadSound(stompUrl);
    preloadSound(winUrl);
    preloadSound(flagpoleUrl);
    preloadSound(musicUrl);

    // All supported block types and their rendering instructions
    let blockTypes = [
      ["rocks",gameTileSheet,1,1,17,0,16,16,32,32,1,1],
      ["bricks",gameTileSheet,1,1,0,221,16,16,32,32,1,1],
      ["block",gameTileSheet,1,1,102,0,16,16,32,32,1,1],
      ["cloudsmall",gameTileSheet,1,1,102,102,16,16,32,32,1,1],
      ["redshroom1",gameTileSheet,1,1,51,34,16,16,32,32,1,1],
      ["redshroom2",gameTileSheet,1,1,68,34,16,16,32,32,1,1],
      ["redshroom3",gameTileSheet,1,1,85,34,16,16,32,32,1,1],
      ["greenshroom1",gameTileSheet,1,1,51,68,16,16,32,32,1,1],
      ["greenshroom2",gameTileSheet,1,1,68,68,16,16,32,32,1,1],
      ["greenshroom3",gameTileSheet,1,1,85,68,16,16,32,32,1,1],
      ["shroomstem1",gameTileSheet,1,1,102,51,16,16,32,32,1,1],
      ["shroomstem2",gameTileSheet,1,1,102,68,16,16,32,32,1,1],
      ["vpipe1",gameTileSheet,1,1,238,0,16,16,32,32,1,1],
      ["vpipe2",gameTileSheet,1,1,255,0,16,16,32,32,1,1],
      ["vpipe3",gameTileSheet,1,1,238,17,16,16,32,32,1,1],
      ["vpipe4",gameTileSheet,1,1,255,17,16,16,32,32,1,1],

      ["switch_on",gameTileSheet,1,1,34,391,16,16,32,32,1,1],
      ["switch_off",gameTileSheet,1,1,51,391,16,16,32,32,1,1],
      ["red_on",gameTileSheet,1,1,34,357,16,16,32,32,1,1],
      ["blue_on",gameTileSheet,1,1,51,357,16,16,32,32,1,1],
      ["red_off",gameTileSheet,1,1,34,374,16,16,32,32,1,1],
      ["blue_off",gameTileSheet,1,1,51,374,16,16,32,32,1,1],

      ["mushroom_block",gameTileSheet,1,1,34,0,16,16,32,32,1,1],
      ["used_block",gameTileSheet,1,1,85,0,16,16,32,32,1,1],
      ["goomba",enemySpriteSheet,2,.4,0,1,16,16,32,32],
      ["spikes",objectSpriteSheet,2,.15,119,1,16,16,32,32],
      ["flagpole",objectSpriteSheet,1,1,765,435,16,16,32,32],
      ["flaghut",objectSpriteSheet,1,1,260,549,16*5,16*5,32,32],
    ];

    // Blocks that should not be drawn
    let nodraw = [
      "inv",
      "flagpole",
      "goomba",
      "koopa",
    ]

    let latedraw = [

    ]

    // Blocks that have no collision
    let noncollide = [
      "goomba",
      "koopa",
      "shroomstem1",
      "shroomstem2",
      "red_off",
      "blue_off",
    ];

    // Blocks that only collide from the top
    let topcollide = [
      "redshroom1",
      "redshroom2",
      "redshroom3",
      "greenshroom1",
      "greenshroom2",
      "greenshroom3",
      "cloudsmall",
    ];

    // Redirect to the builder if joining without having chosen a map to play
    if (!globalGameState || !globalGameState.playingSavedMap && !globalGameState.playingOnlineMap) {
      window.location.href = "builder.html";
    }
    
    // Global variables
    const activation_threshold = 5;

    let canvas = document.getElementById("canvas");
    let context = canvas.getContext("2d");
    context.imageSmoothingEnabled = false;
    updatesPerSecond = 30;

    // Contains functions to allow using multiple inputs or devices to play
    class Controls {
      // Current control scheme for touch screens:
      // Upper 1/3rd and middle 1/5th of screen: jump
      // Middle 1/3rd of screen, excl middle 1/5th: jump and walk to the side that is pressed
      // Bottom 1/3rd of screen, excl middle 1/5th: walk to the side that is pressed

      // If wanting to move left
      left() {
        // Check for keyboard input
        if (keyboard.left || keyboard.a) {
          return true;
        }

        // Go through all touch points and see if any one of them are in the left portion of the screen
        for (let i=0; i<touchscreen.points.length; i++) {
          let point = touchscreen.points[i];
          if (point.x < totalWidth * .4 && point.y > totalHeight * 1/3) {
            return true;
          }
        }
      }

      // If wanting to move right
      right() {
        // Check for keyboard input
        if (keyboard.right || keyboard.d) {
          return true;
        }

        // Go through all touch points and see if any one of them are in the right portion of the screen
        for (let i=0; i<touchscreen.points.length; i++) {
          let point = touchscreen.points[i];
          if (point.x > totalWidth * .6 && point.y > totalHeight * 1/3) {
            return true;
          }
        }
      }

      // If wanting to jump
      jump() {
        // Check for keyboard input
        if (keyboard.up || keyboard.w) {
          return true;
        }

        // Go through all touch points and see if any one of them are in the middle or upper 2/3s of the screen
        for (let i=0; i<touchscreen.points.length; i++) {
          let point = touchscreen.points[i];
          if ((point.x > totalWidth * .4 && point.x < totalWidth * .6) || point.y < totalHeight * 2/3) {
            return true;
          }
        }
      }
    }

    let controls = new Controls();

    let iEntities = [];

    class Entity {
      constructor(respawnX, respawnY, classType) {
        // Set up variables and constants of the entity and Entity class
        this.respawnX = respawnX;
        this.respawnY = respawnY;
        this.x = this.respawnX * blockSize;
        this.y = totalHeight * scale_factor - this.respawnY * blockSize;
        this.xv = 0;
        this.yv = 0;
        this.touching_ground = false;
        this.debug = false;
        this.width = blockSize;
        this.height = blockSize;
        this.classType = classType;
        this.state = 1;
        this.vis_state = 0;
        this.facing = 0;
        this.gravity = 1.6;
      }
      
      // Function that checks if any block is within range to collide
      checkCollision() {
        // Set what xv and yv should be so that it can be set when all collisions are done
        let setXv;
        let setYv;
        let ret;
        
        // Call off the collision detection if not alive
        if (this.state == 0 || this.state == -1) {return null}
        
        // Set char to be in the air so if it isn't on the ground he can't air jump
        this.touching_ground = false;

        // For every block
        for (let i = 0; i < mapArray.length; i++) {
          // Find delta between middle of player and middle of block
          let dx = this.x + this.width / 2 - (mapArray[i][0] * blockSize + blockSize / 2);
          let dy = this.y + this.height / 2 - (totalHeight * scale_factor - mapArray[i][1] * blockSize + blockSize / 2);
          
          // If in range
          if (abs(dy) < this.height/2 + blockSize*2 && abs(dx) < this.width/2 + blockSize*2 || this.classType == "player" && mapArray[i][2] == "flagpole") {

            let x = mapArray[i][0]*blockSize;
            let y = totalHeight * scale_factor - mapArray[i][1]*blockSize;
            let width = blockSize;
            let height = blockSize;

            // The flagpole doesn't have the conventional size
            if (mapArray[i][2] == "flagpole") {
              width = 8;
              height = 304;
              x += 12;
              y -= 272;

              // If in a state to slide down the flagpole, move down a notch
              let yAboveFlagBtm = this.y + this.height - (y + 272 + blockSize)

              if (gameState == 2 && yAboveFlagBtm < 0 && this.classType == "player") {
                if (abs(yAboveFlagBtm) > 6) {this.y += 6;}
                else {this.y = y + 304 - this.height}
                this.x = mapArray[i][0] * blockSize - 16;
              // If at the bottom of the flagpole and flag is done moving, jump off
              } else if (gameState == 2 && this.state < 10 && this.classType == "player" && flagPos <= 0) {
                gameState = 3;
                this.state += 5;
                flagPos = 0;
              }
            }

            if (this.debug) {
              rectangle(x,y,width,height,"red");
            }

            // Action function, will activate when a block is hit. Will give back the velocity that the side was hit with as well as the side as 0-3
            let ent = this;
            function collisionAction(vel,side) {

              // If entity is a player
              if (ent.classType == "player") {
                // Play coin sound when hitting a coin block from the bottom
                if (side == 3 && mapArray[i][2] == "mushroom_block" && abs(vel) > activation_threshold) {
                  // Change to a used block so that the texture changes and the block can't be used again, then play the coin sound a bit later
                  mapArray[i][2] = "used_block";
                  window.setTimeout(function(){
                    playSound(coinUrl,.4);
                    let mushroom = new IEntity("mushroom",mapArray[i][0],mapArray[i][1]+1)
                    iEntities.push(mushroom);
                    mushroom.ai = true;                    
                  },200);
                }

                // ON/OFF switches and changing red/blue blocks to on/off
                if (side == 3 && mapArray[i][2] == "switch_on" && abs(vel) > activation_threshold && !ent.hasFlickedSwitch) {
                  ent.hasFlickedSwitch = true;
                  // Change all switches to off and change red/blue blocks to their correct state
                  for (let i=0; i<mapArray.length; i++) {
                    let block = mapArray[i];
                    if (block[2] == "switch_on") {
                      block[2] = "switch_off";
                    } else if (block[2] == "red_on") {
                      block[2] = "red_off";
                    } else if (block[2] == "blue_off") {
                      block[2] = "blue_on";
                    }
                  }
                  window.setTimeout(function(){
                    ent.hasFlickedSwitch = false;
                  },100);

                } else if (side == 3 && mapArray[i][2] == "switch_off" && abs(vel) > activation_threshold && !ent.hasFlickedSwitch) {
                  ent.hasFlickedSwitch = true;
                  // Change all switches to on and change red/blue blocks to their correct state
                  for (let i=0; i<mapArray.length; i++) {
                    let block = mapArray[i];
                    if (block[2] == "switch_off") {
                      block[2] = "switch_on";
                    } else if (block[2] == "red_off") {
                      block[2] = "red_on";
                    } else if (block[2] == "blue_on") {
                      block[2] = "blue_off";
                    }
                  }
                  window.setTimeout(function(){
                    ent.hasFlickedSwitch = false;
                  },100);
                }

                // If hit flagpole, start going down it
                if (mapArray[i][2] == "flagpole" && ent.state < 5) {
                  activatePhysics = false;
                  ent.state += 5;
                  ent.yv = 0;
                  ent.xv = 0;
                  ent.x = mapArray[i][0] * blockSize - 16
                  // Stop playing music
                  stopSound(musicUrl);
                  // The previous state -1
                  ent.vis_state = (ent.state-6) * 10 + 7;

                  window.setTimeout(function(){
                    playSound(flagpoleUrl);
                    gameState = 2;
                  },500)
                }

                // If hitting a spikes block, damage the player and make it invincible for a while
                if (mapArray[i][2] == "spikes") {
                  ent.hurt();
                }

              // If entity is an iEntity
              } else if (ent.classType == "iEntity") {
                // Change direction of travel if hitting a block side
                if (side == 0 || side == 1) {
                  ent.facing = side;
                }
              }
            }

            // Perform collision detection
            ret = this.collide({x: x, y: y, width: width, height: height, action: collisionAction, name: mapArray[i][2], type: "block"});
            if (ret) {
              if (ret[0] != undefined) {
                setXv = ret[0];
              }
              if (ret[1] != undefined) {
                setYv = ret[1];
              }
            }
          }
        }

        // For every iEntity
        for (let i = 0; i < iEntities.length; i++) {
          
          //Find entity info
          let entity = iEntities[i];
          let dx = abs(this.x + this.width / 2 - entity.x + entity.width / 2);
          let dy = abs(this.y + this.height / 2 - entity.y + entity.height / 2);

          // Action function, will activate when a block or player is hit. Will give back the velocity that the side was hit with as well as the side as 0-3
          let ent = this;
          function collisionAction(vel,side) {

            // If entity is a player
            if (ent.classType == "player") {
              // If hitting a goomba from any side but the top, damage/kill the player and make it invincible for a while
              if (side != 2 && entity.type == "goomba" && ent.state == 2) {
                // Hurt the player
                ent.hurt();

              } else if (side == 2 && entity.type == "goomba" && ent.state > 0) {
                // Stomp the goomba
                entity.kill();

                // Let player jump or bounce on goomba (delayed so collision doesn't affect jump)
                window.setTimeout(function(){
                  if (controls.jump()) {ent.yv = -13.5}
                  else {ent.yv = -8}
                },10);
              }

              // If hitting a koopa from any side but the top, damage/kill the player and make it invincible for a while
              if (side != 2 && entity.type == "koopa" && ent.state == 2) {
                // Hurt the player
                ent.hurt();

              } else if (side == 2 && entity.type == "koopa" && ent.state > 0) {
                // Kill/turn the koopa into a shell
                entity.kill();

                // Let player jump or bounce on goomba (delayed so collision doesn't affect jump)
                window.setTimeout(function(){
                  if (controls.jump()) {ent.yv = -13.5}
                  else {ent.yv = -8}
                },10);
              }

              // Give power up if touching a mushroom
              if (entity.type == "mushroom") {
                if (ent.state == 1 || ent.state == -3) {
                  ent.state = 2;
                  ent.y -= 32;
                  ent.height = 2*blockSize;
                  activatePhysics = false;
                  window.setTimeout(function(){activatePhysics = true},600);
                }

                // Make sure mushroom is removed even if not getting power up
                entity.kill();
              }

            // If entity is an iEntity
            } else if (ent.classType == "iEntity") {
              // Change direction of travel if hitting another entity
              if (side == 0 || side == 1) {
                ent.facing = side;
              }
            }
          }

          // If in range and iEntity is active
          if (dy < this.height/2 + blockSize*2 && dx < this.width/2 + blockSize*2 && entity.state > 0) {
            ret = this.collide({x: entity.x, y: entity.y, width: entity.width, height: entity.height, action: collisionAction, name: entity.type, type: "iEntity", ref: entity});
            if (ret) {
              if (ret[0] != undefined) {
                setXv = ret[0];
              }
              if (ret[1] != undefined) {
                setYv = ret[1];
              }
            }
            
          }
        }
        // Set the values that have been saved
        if (setXv !== undefined) {
          this.xv = setXv;
        }
        if (setYv !== undefined) {
          this.yv = setYv;
        }
      }

      collide(object) {
        // Set what xv and yv should be so that it can be set when all collisions are done
        let setXv;
        let setYv;

        // Call off collision if object is a noncollide block
        if (object.type == "block") {
          for (let i=0; i<noncollide.length; i++) {
            let blockType = noncollide[i];
            if (blockType == object.name) {
              return null;
            }
          }
        }

        // Check if block is topcollide
        let isTopcollide = false;
        if (object.type == "block") {
          for (let i=0; i<topcollide.length; i++) {
            let blockType = topcollide[i];
            if (blockType == object.name) {
              isTopcollide = true;
            }
          }
        }
        
        // Special collision exceptions
        if (object.name == "goomba" && object.ref && object.ref.vis_state < 0 || object.name == "flagpole" && gameState >= 2) {return null}

        // Call off collision if trying to collide the invincible player or mushroom with a goomba
        if (this.classType == "player" && this.state < -1 && object.name == "goomba" || this.classType == "iEntity" && (this.type == "mushroom" && object.name == "goomba" || this.type == "goomba" && object.name == "mushroom")) {return null}

        // Calculate distance to object for this and next tick
        let dxv = abs((this.x + this.xv + this.width/2) - (object.x + object.width/2));
        let dyv = abs((this.y + this.yv + this.height/2) - (object.y + object.height/2));
        let dx = abs((this.x + this.width/2) - (object.x + object.width/2));
        let dy = abs((this.y + this.height/2) - (object.y + object.height/2));

        // Debug line indicating what blocks are being calculated for collision
        if (this.debug) {
          line(this.x + this.xv + this.width/2, this.y + this.yv + this.height/2, object.x + object.width/2, object.y + object.height/2,2, "black");
        }

        // If a full block, use standard collision physics
        if (!isTopcollide) {
          // Check if entity will be inside object next tick
          if (dyv < this.height/2 + object.height/2 && dxv < this.width/2 + object.width/2) {

            // Draw block as blue if entity will collide
            if (this.debug) {
              rectangle(object.x,object.y,object.width,object.height,"blue");
            }
            
            // Check if the entity is entering in the x axis
            if (dx * (this.height / 2 + object.height / 2) > dy * (this.width / 2 + object.width / 2) && dy < this.height/2 + object.height/2) {

              // Change the velocity so the entity intersects the border of the block next tick 
              if (this.x - object.x > 0) {
                // From the left
                object.action(this.xv,0);

                setXv = -(dx - this.width/2 - object.width/2);
              } else {
                // From the right
                object.action(this.xv,1);

                setXv = dx - this.width/2 - object.width/2;
              }
            }
            // Check if the entity is entering in the y axis
            if (dx * (this.height / 2 +object.height / 2) < dy * (this.width / 2 + object.width / 2) && dx < this.width/2 + object.width / 2) {

              // Change the velocity so the entity intersects the border of the block next tick 
              if (this.y - object.y < 0) {
                // From the top
                object.action(this.yv,2);

                setYv = dy - this.height/2 - object.height/2;
                this.touching_ground = true;
                
            } else {
                // From the bottom
                object.action(this.yv,3);

                setYv = -(dy - this.height/2 - object.height/2);
              }
            }
          }
        } else { // If a top collision only block use special collision physics
          // Check if within x range of block, above block and will be inside block next tick
          if (dxv < this.width/2 + object.width/2 && (this.y + this.height) <= object.y && (this.y + this.yv + this.height) >= object.y) {
            // Draw block as blue if entity will collide
            if (this.debug) {
              rectangle(object.x,object.y,object.width,object.height,"blue");
            }

            object.action(this.yv,2);

            setYv = dy - this.height/2 - object.height/2 - .1; // .1 to prevent error where you'll go through at low velocities (float error?)
            this.touching_ground = true;
          }
        }
        return [setXv, setYv];
      }

      // Apply entity velocity to entity position
      update_position() {
        this.x += this.xv;
        this.y += this.yv;

        // When velocity is already calculated, if standing still and on ground, set the vis state to facing
        if (this.classType == "player" && this.xv == 0 && this.touching_ground) {
          this.vis_state = (this.state-1) * 10 + this.facing;
        }
      }
    }
    
    // Player subclass of Entity. Contains all functions related to interaction
    class Player extends Entity {
      constructor(respawnX,respawnY,playerModel) {
        super(respawnX,respawnY,"player");
        this.touching_ground = false;
        this.friction = 1.4;
        this.jumped = false;
        this.playerModel = playerModel;

        // Make sure ON/OFF switch can't be switch on or off multiple times per tick
        this.hasFlickedSwitch = false;
      }
      
      // Apply gravity and input forces to entity velocity, and check for death
      apply_forces() {

        // If not on the ground, add gravity. Lower gravity if holding down jump key and going upwards, for longer jump 
        if (this.yv < 0 && controls.jump() && (this.state > 0 || this.state < -1) && this.state != 5) {
            this.yv += this.gravity / 2.4;
          } else if(this.state != 5) {
            this.yv += this.gravity
        }
        // Limit falling velocity
        if (this.yv > 14) {this.yv = 14}

        // Remove velocity if too small so that there is no super small floats
        if (abs(this.xv) < .3) {
          this.xv = 0
          if (this.state > 0) {this.vis_state = (this.state-1) * 10 + this.facing}
        }

        // Slow down movement using "friction"
        this.xv = this.xv / this.friction;

        // Set the right visual state depending on what state the player is in
        if (this.state > 0 || this.state < -1) {
          if (this.touching_ground) {
            this.vis_state = (this.state-1) * 10 + this.facing + 2;
          } else {
            this.vis_state = (this.state-1) * 10 + this.facing + 4;
          }
        }
            
        // Disable input if touching flag
        if (gameState < 2) {
          // If below y=0 and not already dead, kill the player and respawn
          if (this.y > totalHeight * scale_factor && this.state > 0) {this.kill()}

          // If player is no longer alive, perform death procedure
          if (this.state == 0) {this.kill()}

          // Add sidewards movement and friction if no sideways key is being held down
          if (controls.right() && (this.state > 0 || this.state < -1)) {
            // Left
            this.xv += 1.5;
            this.facing = 0;  
            if (this.xv > 5) {this.xv = 5}      
          } else if (controls.left() && (this.state > 0 || this.state < -1)) {
            // Right
            this.xv -= 1.5;
            this.facing = 1;
            if (this.xv < -5) {this.xv = -5} 
          }

          // Jump
          if (controls.jump() && this.touching_ground && (this.state > 0 || this.state < -1) && ! this.jumped) {
            this.yv = -13.5;
            playSound(jumpUrl, .4);
            // Prevent jumping again if not released jump key and landed
            this.jumped = true
          } else if (! controls.jump() && this.touching_ground) {this.jumped = false}
        }
      }

      moveCanvas() {
        // Sidescroll the canvas if the player is sufficiently far out to the screen and still alive
        if (this.state != -1 && this.x + canvasPosX > totalWidth * scale_factor * .55 && this.xv > 0 && gameState < 2) {
          canvasPosX -= this.xv;
          translate(-this.xv,0);
        } else if (this.state != -1 && this.x + canvasPosX < totalWidth * scale_factor * .45 && this.xv < 0 && canvasPosX < 0) {
          canvasPosX -= this.xv;
          translate(-this.xv,0);
        }
        // Make sure canvas doesn't scroll too far to the left
        if (canvasPosX > 0) {
          translate(-canvasPosX,0);
          canvasPosX = 0;
        }

        // Vertical scroll if too far up on the screen
        if (this.state != -1 && this.y - canvasPosY < totalHeight * scale_factor * .1 && this.yv < 0) {
          let diff = abs((this.y - canvasPosY) - totalHeight * scale_factor * .1);
          canvasPosY -= diff;
          translate(0,diff);
         } else if (this.state != -1 && this.y+this.height - canvasPosY > totalHeight * scale_factor * .7 && this.yv > 0 && canvasPosY < 0) {
          let diff = abs((this.y+this.height - canvasPosY) - totalHeight * scale_factor * .7);
          canvasPosY += diff;
          translate(0,-diff);
        }
        // Make sure canvas doesn't scroll too far down
        if (canvasPosY > 0) {
          translate(0,canvasPosY);
          canvasPosY = 0;
        }
      }

      // Kills player
      kill() {
        // Play death sound and do death animation
        stopSound(musicUrl);
        playSound(deathUrl);
        this.vis_state = -1
        this.state = -1;
        this.gravity = 1.3;
        this.friction = 1.2;

        
        // Pass through 'this' as 'player' so context isn't lost
        let player = this;

        // Set velocity after a delay so that collision doesn't affect velocity
        window.setTimeout(function() {
          player.xv = 10;
          player.yv = -15;
        }, 50);

        // Respawn after the sound/animation is done
        window.setTimeout(function() {
          player.respawn(player);
        }, 3200);
      }

      // Respawns player
      respawn(player) {
        // Set state to alive
        player.state = 1;
        player.vis_state = 0;

        // Reset positions to current starting position
        player.x = player.respawnX * blockSize;
        player.y = totalHeight * scale_factor - player.respawnY * blockSize
        player.xv = 0;
        player.yv = 0;
        player.height = blockSize;
        player.gravity = 1.6;
        player.friction = 1.4;
        
        // Move back the canvas
        translate(-canvasPosX,0);
        canvasPosX = 0;

        // Reset the music
        stopSound(musicUrl);
        loopSound(musicUrl,.3);

        // Reset the map if option is enabled
        if (resetMapOnRespawn) {
          iEntities = [];
          mapArray = JSON.parse(JSON.stringify(savedMapArray));
        }
      }

      // Hurt the player, or kill if small
      hurt() {
        if (this.state == 2) {
          // Damage from big to small
          let lastState = this.state;
          this.state -= 5;
          this.y += 32;
          this.height = 32;
          this.vis_state -= 50;

          // Pass through this so context isn't lost in timeout function
          let player = this;

          // Set invincible, then make hurtable again after 3 seconds
          window.setTimeout(function(){
            if (player.state == lastState - 5) {
              player.state = lastState - 1;
            }
          },3000);

        } else if (this.state == 1) {
          // Kill if small
          this.kill();
        }
        
      }

      // Draw the player
      draw() {
        // Draw player texture depending on player state
        if (this.debug) {
          rectangle(this.x,this.y,this.width,this.height,"green");
          text(this.x,this.y,blockSize,this.vis_state,"black");
        }

        let playerModelOffset;
        if (this.playerModel == 0) {
          playerModelOffset = 0;
        } else if (this.playerModel == 1) {
          playerModelOffset = 148;
        } else if (this.playerModel == 2) {
          playerModelOffset = 295;
        }

        // Small Mario
        if (this.vis_state == -1) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,255,1 + playerModelOffset,16,16,32,32);
        } else if (this.vis_state == 0) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,0,1 + playerModelOffset,16,16,32,32);
        } else if (this.vis_state == 1) {
          drawAnimImg(playerSpriteSheetReversed,1,1,this.x,this.y,597-0,1 + playerModelOffset,-16,16,32,32,-1);
        } else if (this.vis_state == 2) {
          drawAnimImg(playerSpriteSheet,3,1,this.x,this.y,34,1 + playerModelOffset,16,16,32,32);
        } else if (this.vis_state == 3) {
          drawAnimImg(playerSpriteSheetReversed,3,1,this.x,this.y,597-34,1 + playerModelOffset,-16,16,32,32,-1);
        } else if (this.vis_state == 4) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,102,1 + playerModelOffset,16,16,32,32);
        } else if (this.vis_state == 5) {
          drawAnimImg(playerSpriteSheetReversed,1,1,this.x,this.y,597-102,1 + playerModelOffset,-16,16,32,32,-1);
        } else if (this.vis_state == 7) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,221,1 + playerModelOffset,16,16,32,32);
        } 
        // Big Mario
          else if (this.vis_state == 10) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,0,35 + playerModelOffset,16,32,32,64);
        } else if (this.vis_state == 11) {
          drawAnimImg(playerSpriteSheetReversed,1,1,this.x,this.y,597-0,35 + playerModelOffset,-16,32,32,64,-1);
        } else if (this.vis_state == 12) {
          drawAnimImg(playerSpriteSheet,3,1,this.x,this.y,34,35 + playerModelOffset,16,32,32,64);
        } else if (this.vis_state == 13) {
          drawAnimImg(playerSpriteSheetReversed,3,1,this.x,this.y,597-34,35 + playerModelOffset,-16,32,32,64,-1);
        } else if (this.vis_state == 14) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,102,35 + playerModelOffset,16,32,32,64);
        } else if (this.vis_state == 15) {
          drawAnimImg(playerSpriteSheetReversed,1,1,this.x,this.y,597-102,35 + playerModelOffset,-16,32,32,64,-1);
        } else if (this.vis_state == 17) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y+6,221,35 + playerModelOffset,16,32,32,64);
        } 
        // Big Mario getting hurt // Array: [image,x,y,x0=0,y0=0,xs=blockSize,ys=blockSize,xf=blockSize,yf=blockSize]
          else if (this.vis_state == -40) {
          drawTransAnim([[playerSpriteSheet,this.x,this.y,1,1 + playerModelOffset,16,16,32,32],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -39) {
          drawTransAnim([[playerSpriteSheetReversed,this.x,this.y,597-0,1 + playerModelOffset,-16,16,32,32,-1],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -38) {
          drawTransAnim([[playerSpriteSheet,this.x,this.y,34,1 + playerModelOffset,16,16,32,32],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -37) {
          drawTransAnim([[playerSpriteSheetReversed,this.x,this.y,597-34,1 + playerModelOffset,-16,16,32,32,-1],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -36) {
          drawTransAnim([[playerSpriteSheet,this.x,this.y,102,1 + playerModelOffset,16,16,32,32],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -35) {
          drawTransAnim([[playerSpriteSheetReversed,this.x,this.y,597-102,1 + playerModelOffset,-16,16,32,32,-1],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -33) {
          drawTransAnim([[playerSpriteSheet,this.x,this.y,221,1 + playerModelOffset,16,16,32,32],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } 
      }
    }

    // Interactive Entity class
    class IEntity extends Entity {
      constructor(type,respawnX,respawnY) {
        super(respawnX,respawnY,"iEntity");
        this.type = type;
        this.ai = false;
        this.speed = 3; // Default

        // Set speed depending on type of iEntity
        if (this.type == "goomba") {
          this.speed = 2;
          this.ai = true;
          this.facing = 1;

        } else if (this.type == "koopa") {
          this.speed = 2;
          this.ai = true;
          this.facing = 1;

          // Set the right height/pos
          this.height = 36;
          this.y -= 4;
        }
      }

      apply_forces() {
        // Set velocity to the side
        if (this.ai) {
          this.vis_state = this.facing;
          if (this.facing == 0) {
            this.xv = this.speed;
          } else {
            this.xv = -this.speed;
          }
        } else {
          this.xv = 0
        }

        // Gravity
        this.yv += this.gravity

        if (this.y > totalHeight * scale_factor) {
          this.kill();
        }
      }

      kill() {
        if (this.type == "goomba") {
          this.vis_state = -1;
          this.state = 0;
          playSound(stompUrl,.6);
          // Set goomba to unactive state after squished texture has been showed
          let ent = this;
          window.setTimeout(function() {
            ent.state = -1;
          }, 200);

        } else if (this.type == "koopa") {
          this.type = "shell_green";
          this.speed = 5;
          this.y += 4;
          this.height = blockSize;
          this.width = blockSize;

        } else if (this.type == "mushroom") {
          this.state = -1;
        }
      }
    }
    
    // Draw a static image
    function drawImg(image,x,y) {
      context.drawImage(image,0,0,blockSize,blockSize,x * blockSize,totalHeight * scale_factor - y * blockSize,blockSize,blockSize)
    }

    // Draw an animated image. Frames are stacked next to each other (top = first frame) and equal in size
    function drawAnimImg(image,totalFrames,speed,x,y,x0=0,y0=0,xs=16,ys=16,xf=blockSize,yf=blockSize,xoffset=1,yoffset=0) { // Speed should never exceed 2, or it might skip frames
      // Find the frame based on the time, by rounding it down and then dividing it, taking the remainder as the frame
      // 0 = start position of animation, s = size of the animation frame, offset = the offset per frame, f = final drawn resolution
      let frame = Math.floor(performance.now() * speed / 100) % totalFrames;
      context.drawImage(image,xoffset * (frame + 1) + x0 + frame * xs,yoffset * (frame + 1) + y0,xs,ys,x,y,xf,yf)
    }

    // Draws a transition image, like drawAnimImg but flips between two images instead of two frames. Array: [image,x,y,x0=0,y0=0,xs=blockSize,ys=blockSize,xf=blockSize,yf=blockSize]
    function drawTransAnim(imageArray=[],speed) {
      let totalFrames = imageArray.length;
      let frame = Math.floor(performance.now() * speed / 100) % totalFrames;
      let currImage = imageArray[frame];

      context.drawImage(currImage[0],currImage[3],currImage[4],currImage[5],currImage[6],currImage[1],currImage[2],currImage[7],currImage[8])
    }

    // Draw out the map
    function drawMap() {

      // Draw background
      rectangle(-canvasPosX,canvasPosY,totalWidth * scale_factor,totalHeight * scale_factor,"#93bbec");

      // Find middle point on screen
      let screen_mid = -canvasPosX + totalWidth * scale_factor / 2

      // Go through every block
      for (let i = 0; i < mapArray.length; i++) {
        // Find block type
        let type = mapArray[i][2];

        // Only draw if not a nodraw block
        let isNodraw = false;
        for (let i=0; i<nodraw.length; i++) {
          let blockType = nodraw[i];
          if (blockType == type) {
            isNodraw = true;
          }
        }

        let block = blockTypes[0];

        for (let i=0; i<blockTypes.length; i++) {
          if (blockTypes[i][0] === type) {
            block = blockTypes[i];
          }
        }

        if (!isNodraw) {
          // Draw the image with the right texture, and animated if should be
          drawAnimImg(block[1],block[2],block[3],mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,block[4],block[5],block[6],block[7],block[8],block[9],block[10],block[11]);
        }
       
        // Draw/process all exceptions
        if (type == "flagpole") {
          drawAnimImg(objectSpriteSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize - 288,765,452,16,160,32,320);
          drawAnimImg(objectSpriteSheet,1,1,(mapArray[i][0]) * blockSize - 18,totalHeight * scale_factor - mapArray[i][1] * blockSize - flagPos,765,435,16,16,32,32);
        } else if (type == "flaghut") {
          drawAnimImg(objectSpriteSheet,1,1,(mapArray[i][0] - 4) * blockSize,totalHeight * scale_factor - (mapArray[i][1] + 4) * blockSize,260,549,16*5,16*5,32*5,32*5);
        } else if (type == "mushroom_block") {
          drawAnimImg(gameTileSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,34,0,16,16,32,32,1,1);
        } else if (type == "goomba" && abs(mapArray[i][0] * blockSize - screen_mid) < totalWidth * scale_factor * .6 && ! mapArray[i][3]) {
          // If close enough, spawn a goomba
          iEntities.push(new IEntity("goomba",mapArray[i][0],mapArray[i][1]));
          mapArray[i][3] = true;
        } else if (type == "koopa" && abs(mapArray[i][0] * blockSize - screen_mid) < totalWidth * scale_factor * .6 && ! mapArray[i][3]) {
          // If close enough, spawn a koopa
          iEntities.push(new IEntity("koopa",mapArray[i][0],mapArray[i][1]));
          mapArray[i][3] = true;
        }
      }
    }

    // Draw everything that should be drawn on top of the player/other entities
    function drawMapLate() {
      // Go through every block
      for (let i = 0; i < mapArray.length; i++) {
        // Find block type
        let type = mapArray[i][2];

        // Only draw if not a nodraw block
        let isLatedraw = false;
        for (let i=0; i<latedraw.length; i++) {
          let blockType = latedraw[i];
          if (blockType == type) {
            isLatedraw = true;
          }
        }

        let block = blockTypes[0];

        for (let i=0; i<blockTypes.length; i++) {
          if (blockTypes[i][0] === type) {
            block = blockTypes[i];
          }
        }

        if (isLatedraw) {
          // Draw the image with the right texture, and animated if should be
          drawAnimImg(block[1],block[2],block[3],mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,block[4],block[5],block[6],block[7],block[8],block[9],block[10],block[11]);
        }
       
        // Draw/process all exceptions
        if (type == "flaghut") {
          drawAnimImg(objectSpriteSheet,1,1,(mapArray[i][0] - 1.5) * blockSize,totalHeight * scale_factor - (mapArray[i][1] + 1.5) * blockSize,300,589,16*2.5,16*2.5,32*2.5,32*2.5);
        }
      }
    }

    // Perform updates for all active iEntities
    function updateIEntities() {

      // Go through every entity
      for (let i = 0; i < iEntities.length; i++) {

        //Find entity info
        let entity = iEntities[i];
        
        // Update entity if not inactive
        if (entity.state > 0) {
          entity.apply_forces();
          entity.checkCollision();
          entity.update_position();
        }

        // Find middle point on screen
        let screen_mid = -canvasPosX + totalWidth * scale_factor / 2;
        // Remove entity if is too far away to optimize framerates
        if (abs(entity.x - screen_mid) > totalWidth * scale_factor * .6) {
          entity.state = -1;
        } 
      }
    }

    // Draw all active iEntities
    function drawIEntities() {

      // Go through every entity
      for (let i = 0; i < iEntities.length; i++) {

        //Find entity info
        let entity = iEntities[i];
        let type = entity.type;

        // Call off the drawing if iEntity is inactive
        if (entity.state >= 0) {
          // Draw the image with the right texture, and animated if should be
          if (type == "goomba") {
            if (entity.vis_state == 0) {
              drawAnimImg(enemySpriteSheet,2,.4,entity.x,entity.y,0,1,16,16,32,32);
            } else {drawAnimImg(enemySpriteSheet,1,1,entity.x,entity.y,97,1,16,17,32,34);}
          } else if (type == "koopa") {
            if (entity.vis_state == 0) {
              drawAnimImg(enemySpriteSheetReversed,2,.4,entity.x,entity.y - 28,843,34,16,32,32,64);
            } else if (entity.vis_state == 1) {
              drawAnimImg(enemySpriteSheet,2,.4,entity.x,entity.y - 28,0,34,16,32,32,64);
            } else {
              drawAnimImg(enemySpriteSheet,1,1,entity.x,entity.y,97,1,16,17,32,34);
            }
            
          } else if (type == "shell_green") {
            drawAnimImg(enemySpriteSheet,4,1,entity.x,entity.y,77,47,16,16,32,32,1,1);

          } else if (type == "mushroom") {
            drawAnimImg(playerSpriteSheet,1,1,entity.x,entity.y,0,588,16,16,32,32,1,1);
          }
        }
      }
    }

    // Every game update, perform a tick and render
    function update() {
      clearScreen();

      // Render map first of all
      drawMap();

      totalWidth = window.innerWidth;
      totalHeight = window.innerHeight;

      if (gameState > 0) {
        // Perform collision checks and apply physics
        if (activatePhysics) {
          player1.apply_forces();
        }
        player1.checkCollision();

        // If sitting on the pole
        if (player1.state >= 5) {
          player1.vis_state = (player1.state-6) * 10 + 7;
          player1.x = flagpolePosX - 16;
        } else if (player1.state >= 10) {
          player1.vis_state = (player1.state-6) * 10 + 7;
        }

        // Move down flag
        if (gameState == 2) {
          flagPos -= 6;
          if (flagPos <= 0) {
            flagPos = 0;
          }
        }

        // If has reached the bottom of the flagpole, play win sound and jump off it. Go back to the right page after a while
        if (player1.state >= 10 && gameState == 3) {
          activatePhysics = true;
          player1.state -= 10;
          gameState = 4;
          playSound(winUrl);
          player1.facing = 0;
          player1.xv = 7;
          player1.yv = -15;
          player1.friction = 1.15;

          iEntities = {};

          window.setTimeout(function(){
            player1.friction = 1;
            player1.xv = 3;
            player1.vis_state = (player1.state-1) * 10 + 2;
          },1000)

          window.setTimeout(function(){
            // Remember that the course has been played through
            globalGameState.coursePlayed = true;

            // Go back to the right place, else refresh the page
            if (globalGameState.playingSavedMap) {
              window.location.href = "builder.html";
            } else if (globalGameState.playingOnlineMap) {
              window.location.href = "index.html";
            } else {
              location.reload();
            }
          },6000)
        }

        if (activatePhysics) {
          player1.update_position();
          updateIEntities();
        }
        
        // Render map and objects
        player1.moveCanvas();
        drawIEntities();
        player1.draw();

        drawMapLate();

        if (player1.debug) {console.log(player1.yv +" "+ player1.xv)}
      
      } else {
        // Draw character selection screen
        let mario_x = (totalWidth / 2 - 400)*scale_factor;
        let luigi_x = (totalWidth / 2 - 100)*scale_factor;
        let toad_x = (totalWidth / 2 + 200)*scale_factor;
        let char_y = (totalHeight / 2)*scale_factor;
        rectangle(0,0,totalWidth * scale_factor,totalHeight * scale_factor,"yellow");
        text(totalWidth * scale_factor / 2 - totalWidth * scale_factor / 2.8,(totalHeight / 2 - 100)*scale_factor,totalWidth * scale_factor / 20,"Pick a character!","black")
        drawAnimImg(playerSpriteSheet,3,.4,mario_x,char_y,34,1,16,16,64,64);
        drawAnimImg(playerSpriteSheet,3,.4,luigi_x,char_y,34,1 + 148,16,16,64,64);
        drawAnimImg(playerSpriteSheet,3,.4,toad_x,char_y,34,1 + 295,16,16,64,64);

        // See if any player is being clicked on and create that player
        let dx_mario = abs(mouse.x*scale_factor - mario_x - 32)
        let dx_luigi = abs(mouse.x*scale_factor - luigi_x - 32)
        let dx_toad = abs(mouse.x*scale_factor - toad_x - 32)
        let dy = abs(mouse.y*scale_factor - char_y - 32);
        if (dy < 32 && mouse.left) {
          if (dx_mario < 32) {
            gameState = 1;
            player1 = new Player(0,2,0);
            loopSound(musicUrl,.3);
          } else if (dx_luigi < 32) {
            gameState = 1;
            player1 = new Player(0,2,1);
            loopSound(musicUrl,.3);
          } else if (dx_toad < 32) {
            gameState = 1;
            player1 = new Player(0,2,2);
            loopSound(musicUrl,.3);
          }
        }
      }
    }
    
  </script>
</body>