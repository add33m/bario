<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <title>Bario by add33m</title>
  <link rel="icon" href="barioicon.ico">
</head>

<body>
  <script src="simple.js">

    /*
      Made by add33m with (a bunch of) help from pelp3!
      **pelp3Ngine 2.3**
    */

    // Map
    let savedMapArray = [[-1,2,"inv"],[-1,3,"inv"],[-1,4,"inv"],[-1,5,"inv"],[-1,6,"inv"],[-1,7,"inv"],[-1,8,"inv"],[-1,9,"inv"],[-1,10,"inv"],[-1,11,"inv"],[0,1,"bricks"],[1,1,"bricks"],[2,1,"bricks"],[2,5,"coin_block"],[3,1,"bricks"],[4,1,"bricks"],[4,2,"block"],[5,1,"bricks"],[5,2,"goomba"],[6,2,"goomba"],[7,6,"block"],[6,1,"bricks"],[7,1,"bricks"],[8,1,"bricks"],[9,1,"bricks"],[7,2,"block"],[11,3,"flagpole"],[11,2,"block"],[10,1,"bricks"],[11,1,"bricks"],[12,1,"bricks"],[13,1,"bricks"],[14,1,"bricks"],[15,1,"bricks"],[16,2,"inv"]];
    const blockSize = 32;
    const resetMapOnRespawn = true;

    // Look for the current global/saved state of the game
    let globalGameState = localStorage.getItem("currentGameState");
    if (globalGameState) {
      globalGameState = JSON.parse(globalGameState);
    }

    // Look if a map is locally saved, and use that if supposed to
    let savedMap = localStorage.getItem("currentBuiltMap");
    if (savedMap && globalGameState.playingSavedMap) {
      savedMapArray = JSON.parse(savedMap);
      savedMapArray.unshift([-1,2,"inv"],[-1,3,"inv"],[-1,4,"inv"],[-1,5,"inv"],[-1,6,"inv"],[-1,7,"inv"],[-1,8,"inv"],[-1,9,"inv"],[-1,10,"inv"],[-1,11,"inv"]);
    }

    // If window is getting unloaded or leaving, save game state
    window.onbeforeunload = function(){
      localStorage.setItem("currentGameState",JSON.stringify(globalGameState))
    };

    let mapArray = JSON.parse(JSON.stringify(savedMapArray));

    // Scaling (12 blocks tall)
    const scale_factor = blockSize * 12 / totalHeight;
    scale(1 / scale_factor,1 / scale_factor);

    // Character selection
    let gameState = 0;
    let flagpolePosX;
    let flagPos = blockSize * 8;

    for (let i = 0; i < mapArray.length; i++) {
      if (mapArray[i][2] == "flagpole") {
        flagpolePosX = mapArray[i][0] * blockSize;
      }
    }

    // Reserve var for player
    let player1;

    // Pause physics when giving player a power up
    let activatePhysics = true;

    // Clears console to prevent memory usage and lag
    if (false) {
      window.setInterval(function(){
        console.clear()
      },10000)
    }
    
    // Canvas moving
    let canvasPos = 0;
    
    // ASSETS:
    // Define and preload textures
    const playerSpriteSheet = new Image();
    playerSpriteSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/617650288408395776/SMBPlayerSprites.png";
    const playerSpriteSheetReversed = new Image();
    playerSpriteSheetReversed.src = "https://cdn.discordapp.com/attachments/489085929726935041/617651006263656451/SMBPlayerSpritesReversed.png";
    const enemySpriteSheet = new Image();
    enemySpriteSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/617817625778454537/SMBEnemySprites.png";
    const objectSpriteSheet = new Image();
    objectSpriteSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/618484986642825217/SMBObjectSprites.png";
    const gameTileSheet = new Image();
    gameTileSheet.src = "https://cdn.discordapp.com/attachments/489085929726935041/617422854409158676/SMBTileset.png";

    // Sounds
    const deathUrl = "https://cdn.discordapp.com/attachments/489085929726935041/616335506216583217/smb_mariodie.wav";
    const jumpUrl = "https://cdn.discordapp.com/attachments/489085929726935041/616353716068548697/smb_jumpsmall.wav";
    const coinUrl = "https://cdn.discordapp.com/attachments/489085929726935041/617145664618496016/smb_coin.wav";
    const stompUrl = "https://cdn.discordapp.com/attachments/489085929726935041/617815051428036608/smb_stomp.wav";
    const winUrl = "https://cdn.discordapp.com/attachments/489085929726935041/619212400532652068/smb_win.mp3";
    const flagpoleUrl = "https://cdn.discordapp.com/attachments/489085929726935041/619967226564313088/smb_flagpole.wav";
    const musicUrl = "http://www.mariomayhem.com/downloads/sound_tracks/Super_Mario_Bros._1/01-main-theme-overworld.mp3";

    // Preload sounds
    preloadSound(deathUrl);
    preloadSound(jumpUrl);
    preloadSound(coinUrl);
    preloadSound(stompUrl);
    preloadSound(winUrl);
    preloadSound(flagpoleUrl);
    preloadSound(musicUrl);

    // Global variables
    const activation_threshold = 5;

    let canvas = document.getElementById("canvas");
    let context = canvas.getContext("2d");
    context.imageSmoothingEnabled = false;
    updatesPerSecond = 30;

    let iEntities = [];

    class Entity {
      constructor(respawnX, respawnY, classType) {
        // Set up variables and constants of the entity and Entity class
        this.respawnX = respawnX;
        this.respawnY = respawnY;
        this.x = this.respawnX * blockSize;
        this.y = totalHeight * scale_factor - this.respawnY * blockSize;
        this.xv = 0;
        this.yv = 0;
        this.touching_ground = false;
        this.debug = false;
        this.width = blockSize;
        this.height = blockSize;
        this.classType = classType;
        this.state = 1;
        this.vis_state = 0;
        this.facing = 0;
        this.gravity = 1.6;
      }
      
      // Function that checks if any block is within range to collide
      checkCollision() {
        
        // Call off the collision detection if not alive
        if (this.state == 0 || this.state == -1) {return null}
        
        // Set char to be in the air so if it isn't on the ground he can't air jump
        this.touching_ground = false;

        // For every block
        for (let i = 0; i < mapArray.length; i++) {
          // Find delta between middle of player and middle of block
          let dx = this.x + this.width / 2 - (mapArray[i][0] * blockSize + blockSize / 2);
          let dy = this.y + this.height / 2 - (totalHeight * scale_factor - mapArray[i][1] * blockSize + blockSize / 2);
          
          // If in range
          if (abs(dy) < this.height/2 + blockSize*2 && abs(dx) < this.width/2 + blockSize*2 || this.classType == "player" && mapArray[i][2] == "flagpole") {

            let x = mapArray[i][0]*blockSize;
            let y = totalHeight * scale_factor - mapArray[i][1]*blockSize;
            let width = blockSize;
            let height = blockSize;

            // The flagpole doesn't have the conventional size
            if (mapArray[i][2] == "flagpole") {
              width = 8;
              height = 304;
              x += 12;
              y -= 272;

              // If in a state to slide down the flagpole, move down a notch
              let yAboveFlagBtm = this.y + this.height - (y + 272 + blockSize)

              if (gameState == 2 && yAboveFlagBtm < 0 && this.classType == "player") {

                if (abs(yAboveFlagBtm) > 6) {this.y += 6;}
                else {this.y = y + 272}
                this.x = mapArray[i][0] * blockSize - 16;
              // If at the bottom of the flagpole and flag is done moving, jump off
              } else if (gameState == 2 && this.state < 10 && this.classType == "player" && flagPos <= 0) {
                gameState = 3;
                this.state += 5;
                flagPos = 0;
              }
            }

            if (this.debug) {
              rectangle(x,y,width,height,"red");
            }

            // Action function, will activate when a block is hit. Will give back the velocity that the side was hit with as well as the side as 0-3
            let ent = this;
            function collisionAction(vel,side) {

              // If entity is a player
              if (ent.classType == "player") {
                // Play coin sound when hitting a coin block from the bottom
                if (side == 3 && mapArray[i][2] == "coin_block" && abs(vel) > activation_threshold) {
                  // Change to a used block so that the texture changes and the block can't be used again, then play the coin sound a bit later
                  mapArray[i][2] = "used_block";
                  window.setTimeout(function(){
                    playSound(coinUrl,.4);
                    let mushroom = new IEntity("mushroom",mapArray[i][0],mapArray[i][1]+1)
                    iEntities.push(mushroom);
                    mushroom.ai = true;
                    mushroom.facing = 1;
                  },200)
                }

                // If hit flagpole, start going down it
                if (mapArray[i][2] == "flagpole" && ent.state < 5) {
                  activatePhysics = false;
                  ent.state += 5;
                  ent.yv = 0;
                  ent.xv = 0;
                  ent.x = mapArray[i][0] * blockSize - 16
                  // Stop playing music
                  stopSound(musicUrl);
                  // The previous state -1
                  ent.vis_state = (ent.state-6) * 10 + 7;

                  window.setTimeout(function(){
                    playSound(flagpoleUrl);
                    gameState = 2;
                  },500)
                }

              // If entity is an iEntity
              } else if (ent.classType == "iEntity") {
                // Change direction of travel if hitting a block side
                if (side == 0 || side == 1) {
                  ent.facing = abs(1-side);
                }
              }
            }

            // Perform collision detection
            this.collide({x: x, y: y, width: width, height: height, action: collisionAction, name: mapArray[i][2], type: "block"});
          }
        }

        // For every iEntity
        for (let i = 0; i < iEntities.length; i++) {
          
          //Find entity info
          let entity = iEntities[i];
          let dx = abs(this.x + this.width / 2 - entity.x + entity.width / 2);
          let dy = abs(this.y + this.height / 2 - entity.y + entity.height / 2);

          // Action function, will activate when a block or player is hit. Will give back the velocity that the side was hit with as well as the side as 0-3
          let ent = this;
          function collisionAction(vel,side) {

            // If entity is a player
            if (ent.classType == "player") {
              // If hitting a goomba from any side but the top, damage/kill the player and make it invincible for a while
              if (side != 2 && entity.type == "goomba" && ent.state > 1) {
                let lastState = ent.state;
                ent.state -= 5;
                ent.y += 32;
                ent.height = 32; 
                ent.vis_state -= 50
                window.setTimeout(function(){
                  ent.state = lastState - 1;                 
                },3000);

              } else if (side != 2 && entity.type == "goomba" && ent.state == 1) {
                // Kill the player if small
                ent.state = 0;

              } else if (side == 2 && entity.type == "goomba" && ent.state > 0) {
                // Stomp the goomba
                entity.kill();

                // Let player jump or bounce on goomba (delayed so collision doesn't affect jump)
                window.setTimeout(function(){
                  if (keyboard["w"]) {ent.yv = -13.5}
                  else {ent.yv = -8}
                },10)
              }

              // Give power up if touching a mushroom
              if (ent.state < 2 && entity.type == "mushroom") {
                entity.kill();
                ent.state += 1;
                ent.vis_state += 10;
                ent.y -= 32;
                ent.height = 64;
                activatePhysics = false;
                window.setTimeout(function(){activatePhysics = true},600);
              }

            // If entity is an iEntity
            } else if (ent.classType == "iEntity") {
              // Change direction of travel if hitting another entity
              if (side == 0 || side == 1) {
                ent.facing = abs(1-side);
              }
            }
          }

          // If in range and iEntity is active
          if (dy < this.height/2 + blockSize*2 && dx < this.width/2 + blockSize*2 && entity.state > 0) {
            this.collide({x: entity.x, y: entity.y, width: entity.width, height: entity.height, action: collisionAction, name: entity.type, type: "iEntity", ref: entity});
          }
        }
      }

      collide(object) {
        // Call off collision if object isn't a valid collision block
        if (object.type == "block" && object.name == "goomba" || object.name == "goomba" && object.ref && object.ref.vis_state < 0 || object.name == "flagpole" && gameState >= 2) {return null}

        // Call off collision if trying to collide the invincible player or mushroom with a goomba
        if (this.classType == "player" && this.state < -1 && object.name == "goomba" || this.classType == "iEntity" && (this.type == "mushroom" && object.name == "goomba" || this.type == "goomba" && object.name == "mushroom")) {return null}

        // Calculate distance to object for this and next tick
        let dxv = abs((this.x + this.xv + this.width/2) - (object.x + object.width/2));
        let dyv = abs((this.y + this.yv + this.height/2) - (object.y + object.height/2));
        let dx = abs((this.x + this.width/2) - (object.x + object.width/2));
        let dy = abs((this.y + this.height/2) - (object.y + object.height/2));

        // Debug line indicating what blocks are being calculated for collision
        if (this.debug) {
          line(this.x + this.xv + this.width/2, this.y + this.yv + this.height/2, object.x + object.width/2, object.y + object.height/2, "black");
        }

        // Check if entity will be inside object next tick
        if (dyv < this.height/2 + object.height/2 && dxv < this.width/2 + object.width/2) {
          
          // Check if the entity is entering in the x axis
          if (dx * (this.height / 2 + object.height / 2) > dy * (this.width / 2 + object.width / 2) && dy < this.height/2 + object.height/2) {

            // Change the velocity so the entity intersects the border of the block next tick 
            if (this.x - object.x > 0) {
              // From the left
              object.action(this.xv,0)

              this.xv = -(dx - this.width/2 - object.width/2);
            } else {
              // From the right
              object.action(this.xv,1)

              this.xv = dx - this.width/2 - object.width/2;
            }
          }
          // Check if the entity is entering in the y axis
          if (dx * (this.height / 2 +object.height / 2) < dy * (this.width / 2 + object.width / 2) && dx < this.width/2 + object.width / 2) {

            // Change the velocity so the entity intersects the border of the block next tick 
            if (this.y - object.y < 0) {
              // From the top
              object.action(this.yv,2)

              this.yv = dy - this.height/2 - object.height/2;
              this.touching_ground = true;
              
            } else {
              // From the bottom
              object.action(this.yv,3)

              this.yv = -(dy - this.height/2 - object.height/2);
            }
          }
        }
      }

      // Apply entity velocity to entity position
      update_position() {
        this.x += this.xv;
        this.y += this.yv;

        // When velocity is already calculated, if standing still and on ground, set the vis state to facing
        if (this.classType == "player" && this.xv == 0 && this.touching_ground) {
          this.vis_state = (this.state-1) * 10 + this.facing;
        }
      }
    }
    
    // Player subclass of Entity. Contains all functions related to interaction
    class Player extends Entity {
      constructor(respawnX,respawnY,playerModel) {
        super(respawnX,respawnY,"player");
        this.touching_ground = false;
        this.friction = 1.4;
        this.jumped = false;
        this.playerModel = playerModel;
      }
      
      // Apply gravity and input forces to entity velocity, and check for death
      apply_forces() {

        // If not on the ground, add gravity. Lower gravity if holding down jump key for longer jump and going upwards
        if (this.yv < 0 && keyboard["w"] && (this.state > 0 || this.state < -1) && this.state != 5) {
            this.yv += this.gravity / 2.4;
          } else if(this.state != 5) {
            this.yv += this.gravity
        }
        // Limit falling velocity
        if (this.yv > 14) {this.yv = 14}

        // Remove velocity if too small so that there is no super small floats
        if (abs(this.xv) < .3) {
          this.xv = 0
          if (this.state > 0) {this.vis_state = (this.state-1) * 10 + this.facing}
        }

        // Slow down movement using "friction"
        this.xv = this.xv / this.friction;

        // Set the right visual state depending on what state the player is in
        if (this.state > 0 || this.state < -1) {
          if (this.touching_ground) {
            this.vis_state = (this.state-1) * 10 + this.facing + 2;
          } else {
            this.vis_state = (this.state-1) * 10 + this.facing + 4;
          }
        }
            
        // Disable input if touching flag
        if (gameState < 2) {
          // If below y=0 and not already dead, kill the player and respawn
          if (this.y > totalHeight * scale_factor && this.state > 0) {this.kill()}

          // If player is no longer alive, perform death procedure
          if (this.state == 0) {this.kill()}

          // Add sidewards movement and friction if no sideways key is being held down
          if (keyboard["d"] && (this.state > 0 || this.state < -1)) {
            // Left
            this.xv += 1.5;
            this.facing = 0;  
            if (this.xv > 5) {this.xv = 5}      
          } else if (keyboard["a"] && (this.state > 0 || this.state < -1)) {
            // Right
            this.xv -= 1.5;
            this.facing = 1;
            if (this.xv < -5) {this.xv = -5} 
          }

          // Jump
          if (keyboard["w"] && this.touching_ground && (this.state > 0 || this.state < -1) && ! this.jumped) {
            this.yv = -13.5;
            playSound(jumpUrl, .4);
            // Prevent jumping again if not released jump key and landed
            this.jumped = true
          } else if (! keyboard["w"] && this.touching_ground) {this.jumped = false}
        }

        // Sidescroll the canvas if the player is sufficiently far out to the screen
        if (this.x + canvasPos > totalWidth * scale_factor * .55 && this.xv > 0 && -canvasPos + (totalWidth * scale_factor) < (flagpolePosX + blockSize * 7)) {
          canvasPos -= this.xv;
          translate(-this.xv,0);
        } else if (this.x + canvasPos < totalWidth * scale_factor * .45 && this.xv < 0 && canvasPos < 0) {
          canvasPos -= this.xv;
          translate(-this.xv,0);
        }
        // Make sure canvas doesn't scroll too far in either direction
        if (canvasPos > 0) {
          translate(-canvasPos,0);
          canvasPos = 0;
        } else if (-canvasPos + (totalWidth * scale_factor) > (flagpolePosX + blockSize * 7)) {
          // Find how much too far it went
          let diff = -canvasPos + (totalWidth * scale_factor) - (flagpolePosX + blockSize * 7);
          translate(diff,0);
          canvasPos += diff;
        }

      }

      // Kills player
      kill() {
        // Play death sound and do death animation
        stopSound(musicUrl);
        playSound(deathUrl);
        this.vis_state = -1
        this.state = -1;
        this.yv = -15;
        this.xv = 10;
        this.gravity = 1.3;
        this.friction = 1.2;

        // Respawn after the sound/animation is done
        let player = this;
          window.setTimeout(function() {
            // Pass through 'this' as 'player' so context isn't lost
            player.respawn(player)
          }, 3200);
      }

      // Respawns player
      respawn(player) {
        // Set state to alive
        player.state = 1;
        player.vis_state = 0;

        // Reset positions to current starting position
        player.x = player.respawnX * blockSize;
        player.y = totalHeight * scale_factor - player.respawnY * blockSize
        player.xv = 0;
        player.yv = 0;
        player.height = 32;
        player.gravity = 1.6;
        player.friction = 1.4;
        
        // Move back the canvas
        translate(-canvasPos,0);
        canvasPos = 0;

        // Reset the music
        stopSound(musicUrl);
        loopSound(musicUrl,.3);

        // Reset the map if option is enabled
        if (resetMapOnRespawn) {
          iEntities = [];
          mapArray = JSON.parse(JSON.stringify(savedMapArray));
        }
      }

      // Draw the player
      draw() {
        // Draw player texture depending on player state
        if (this.debug) {
          rectangle(this.x,this.y,blockSize,blockSize,"green");
          text(this.x,this.y,blockSize,this.vis_state,"black");
        }

        let playerModelOffset;
        if (this.playerModel == 0) {
          playerModelOffset = 0;
        } else if (this.playerModel == 1) {
          playerModelOffset = 148;
        } else if (this.playerModel == 2) {
          playerModelOffset = 295;
        }

        // Small Mario
        if (this.vis_state == -1) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,255,1 + playerModelOffset,16,16,32,32);
        } else if (this.vis_state == 0) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,0,1 + playerModelOffset,16,16,32,32);
        } else if (this.vis_state == 1) {
          drawAnimImg(playerSpriteSheetReversed,1,1,this.x,this.y,597-0,1 + playerModelOffset,-16,16,32,32,-1);
        } else if (this.vis_state == 2) {
          drawAnimImg(playerSpriteSheet,3,1,this.x,this.y,34,1 + playerModelOffset,16,16,32,32);
        } else if (this.vis_state == 3) {
          drawAnimImg(playerSpriteSheetReversed,3,1,this.x,this.y,597-34,1 + playerModelOffset,-16,16,32,32,-1);
        } else if (this.vis_state == 4) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,102,1 + playerModelOffset,16,16,32,32);
        } else if (this.vis_state == 5) {
          drawAnimImg(playerSpriteSheetReversed,1,1,this.x,this.y,597-102,1 + playerModelOffset,-16,16,32,32,-1);
        } else if (this.vis_state == 7) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,221,1 + playerModelOffset,16,16,32,32);
        } 
        // Big Mario
          else if (this.vis_state == 10) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,0,35 + playerModelOffset,16,32,32,64);
        } else if (this.vis_state == 11) {
          drawAnimImg(playerSpriteSheetReversed,1,1,this.x,this.y,597-0,35 + playerModelOffset,-16,32,32,64,-1);
        } else if (this.vis_state == 12) {
          drawAnimImg(playerSpriteSheet,3,1,this.x,this.y,34,35 + playerModelOffset,16,32,32,64);
        } else if (this.vis_state == 13) {
          drawAnimImg(playerSpriteSheetReversed,3,1,this.x,this.y,597-34,35 + playerModelOffset,-16,32,32,64,-1);
        } else if (this.vis_state == 14) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,102,35 + playerModelOffset,16,32,32,64);
        } else if (this.vis_state == 15) {
          drawAnimImg(playerSpriteSheetReversed,1,1,this.x,this.y,597-102,35 + playerModelOffset,-16,32,32,64,-1);
        } else if (this.vis_state == 17) {
          drawAnimImg(playerSpriteSheet,1,1,this.x,this.y,221,35 + playerModelOffset,16,32,32,64);
        } 
        // Big Mario getting hurt // Array: [image,x,y,x0=0,y0=0,xs=blockSize,ys=blockSize,xf=blockSize,yf=blockSize]
          else if (this.vis_state == -40) {
          drawTransAnim([[playerSpriteSheet,this.x,this.y,1,1 + playerModelOffset,16,16,32,32],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -39) {
          drawTransAnim([[playerSpriteSheetReversed,this.x,this.y,597-0,1 + playerModelOffset,-16,16,32,32,-1],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -38) {
          drawTransAnim([[playerSpriteSheet,this.x,this.y,34,1 + playerModelOffset,16,16,32,32],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -37) {
          drawTransAnim([[playerSpriteSheetReversed,this.x,this.y,597-34,1 + playerModelOffset,-16,16,32,32,-1],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -36) {
          drawTransAnim([[playerSpriteSheet,this.x,this.y,102,1 + playerModelOffset,16,16,32,32],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -35) {
          drawTransAnim([[playerSpriteSheetReversed,this.x,this.y,597-102,1 + playerModelOffset,-16,16,32,32,-1],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } else if (this.vis_state == -33) {
          drawTransAnim([[playerSpriteSheet,this.x,this.y,221,1 + playerModelOffset,16,16,32,32],[playerSpriteSheet,this.x,this.y,1000,1000,16,16,32,32]],.8);
        } 
      }
    }

    // Interactive Entity class
    class IEntity extends Entity {
      constructor(type,respawnX,respawnY) {
        super(respawnX,respawnY,"iEntity");
        this.type = type;
        this.ai = false;
        this.speed = 3; // Default

        // Set speed depending on type of iEntity
        if (this.type == "goomba") {
          this.speed = 2;
          this.ai = true;
        }
      }

      apply_forces() {
        // Set velocity to the side
        if (this.ai) {
          if (this.facing == 0) {
            this.xv = -this.speed;
          } else {
            this.xv = this.speed;
          }
        } else {
          this.xv = 0
        }

        // Gravity
        this.yv += this.gravity

        if (this.y > totalHeight * scale_factor) {
          this.kill();
        }
      }

      kill() {
        if (this.type == "goomba") {
          this.vis_state = -1;
          this.state = 0;
          playSound(stompUrl,.6);
          // Set goomba to unactive state after squished texture has been showed
          let ent = this;
          window.setTimeout(function() {
            ent.state = -1;
          }, 200);

        } else if (this.type == "mushroom") {
          this.state = -1;
        }
      }
    }
    
    // Draw a static image
    function drawImg(image,x,y) {
      context.drawImage(image,0,0,blockSize,blockSize,x * blockSize,totalHeight * scale_factor - y * blockSize,blockSize,blockSize)
    }

    // Draw an animated image. Frames are stacked next to each other (top = first frame) and equal in size
    function drawAnimImg(image,totalFrames,speed,x,y,x0=0,y0=0,xs=16,ys=16,xf=blockSize,yf=blockSize,xoffset=1,yoffset=0) { // Speed should never exceed 2, or it might skip frames
      // Find the frame based on the time, by rounding it down and then dividing it, taking the remainder as the frame
      // 0 = start position of animation, s = size of the animation frame, offset = the offset per frame, f = final drawn resolution
      let frame = Math.floor(performance.now() * speed / 100) % totalFrames;
      context.drawImage(image,xoffset * (frame + 1) + x0 + frame * xs,yoffset * (frame + 1) + y0,xs,ys,x,y,xf,yf)
    }

    // Draws a transition image, like drawAnimImg but flips between two images instead of two frames. Array: [image,x,y,x0=0,y0=0,xs=blockSize,ys=blockSize,xf=blockSize,yf=blockSize]
    function drawTransAnim(imageArray=[],speed) {
      let totalFrames = imageArray.length;
      let frame = Math.floor(performance.now() * speed / 100) % totalFrames;
      let currImage = imageArray[frame];

      context.drawImage(currImage[0],currImage[3],currImage[4],currImage[5],currImage[6],currImage[1],currImage[2],currImage[7],currImage[8])
    }

    // Draw out the map
    function drawMap() {

      // Draw background
      rectangle(-canvasPos,0,totalWidth * scale_factor,totalHeight * scale_factor,"#93bbec");

      // Find middle point on screen
      let screen_mid = canvasPos + totalWidth * scale_factor / 2

      // Go through every block
      for (let i = 0; i < mapArray.length; i++) {
        // Find block type
        let type = mapArray[i][2];

        // Draw if not an invisible block
        if (type != "inv") {

          // Draw the image with the right texture, and animated if should be
          if (type == "bricks") {
            drawAnimImg(gameTileSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,0,221,16,16,32,32,1,1);
          } else if (type == "block") {
            drawAnimImg(gameTileSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,102,0,16,16,32,32,1,1);
          } else if (type == "flagpole") {
            drawAnimImg(objectSpriteSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize - 288,765,452,16,160,32,320);
            drawAnimImg(objectSpriteSheet,1,1,(mapArray[i][0]) * blockSize - 18,totalHeight * scale_factor - mapArray[i][1] * blockSize - flagPos,765,435,16,16,32,32);
          } else if (type == "coin_block") {
            drawAnimImg(gameTileSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,34,0,16,16,32,32,1,1);
          } else if (type == "used_block") {
            drawAnimImg(gameTileSheet,1,1,mapArray[i][0] * blockSize,totalHeight * scale_factor - mapArray[i][1] * blockSize,85,0,16,16,32,32,1,1);
          } else if (type == "goomba" && abs(mapArray[i][0] * blockSize - screen_mid) < totalWidth * scale_factor && ! mapArray[i][3]) {
            // If close enough, spawn a goomba
            iEntities.push(new IEntity("goomba",mapArray[i][0],mapArray[i][1]));
            mapArray[i][3] = true;
          }
        }
      }
    }

    // Perform physics for all active iEntities
    function updateIEntities() {

      // Go through every entity
      for (let i = 0; i < iEntities.length; i++) {

        //Find entity info
        let entity = iEntities[i];
        
        // Update entity if not inactive
        if (entity.state > 0) {
          entity.apply_forces();
          entity.checkCollision();
          entity.update_position();
        }
      }
    }

    // Draw all active iEntities
    function drawIEntities() {

      // Go through every entity
      for (let i = 0; i < iEntities.length; i++) {

        //Find entity info
        let entity = iEntities[i];
        let type = entity.type;

        // Call off the drawing if iEntity is inactive
        if (entity.state < 0) {return null}

        // Draw the image with the right texture, and animated if should be
        if (type == "goomba") {
          if (entity.vis_state == 0) {
            drawAnimImg(enemySpriteSheet,2,.4,entity.x,entity.y,0,1,16,16,32,32);
          } else {drawAnimImg(enemySpriteSheet,1,1,entity.x,entity.y,97,1,16,17,32,34);}
        } else if (type == "test") {
          drawImg(bricksUrl,mapArray[i][0],mapArray[i][1]);
        } else if (type == "mushroom") {
          drawAnimImg(playerSpriteSheet,1,1,entity.x,entity.y,0,588,16,16,32,32,1,1);
        }
      }
    }

    // Every game update, perform a tick and render
    function update() {
      clearScreen();

      totalWidth = window.innerWidth;
      totalHeight = window.innerHeight;

      if (gameState > 0) {
        drawMap();

        // Perform collision checks and apply physics
        if (activatePhysics) {
          player1.apply_forces();
        }
        player1.checkCollision();

        // If sitting on the pole
        if (player1.state >= 5) {
          player1.vis_state = (player1.state-6) * 10 + 7;
          player1.x = flagpolePosX - 16;
        } else if (player1.state >= 10) {
          player1.vis_state = (player1.state-6) * 10 + 7;
        }

        // Move down flag
        if (gameState == 2) {
          flagPos -= 6;
          if (flagPos <= 0) {
            flagPos = 0;
          }
        }

        // If has reached the bottom of the flagpole, play win sound and jump off it. Go back to the right page after a while
        if (player1.state >= 10 && gameState == 3) {
          activatePhysics = true;
          player1.state -= 10;
          gameState = 4;
          playSound(winUrl);
          player1.xv = 7;
          player1.yv = -15;
          player1.friction = 1.15;

          iEntities = {};

          window.setTimeout(function(){
            player1.friction = 1;
            player1.xv = 3;
            player1.vis_state = (player1.state-1) * 10 + 2;
          },1000)

          window.setTimeout(function(){
            // Remember that the course has been played through
            globalGameState.coursePlayed = true;
            // Go back to the builder if playing a local map, else refresh the page
            if (globalGameState.playingSavedMap) {
              location.assign("builder.html");
            } else {
              location.reload();
            }
          },6000)
        }

        if (activatePhysics) {
          player1.update_position();
          updateIEntities();
        }
        
        // Render map and objects
        drawIEntities();
        player1.draw(); 

        if (player1.debug) {console.log(player1.yv +" "+ player1.xv)}
      
      } else {
        // Draw character selection screen
        let mario_x = (totalWidth / 2 - 400)*scale_factor;
        let luigi_x = (totalWidth / 2 - 100)*scale_factor;
        let toad_x = (totalWidth / 2 + 200)*scale_factor;
        let char_y = (totalHeight / 2)*scale_factor;
        rectangle(0,0,totalWidth * scale_factor,totalHeight * scale_factor,"yellow");
        text(totalWidth * scale_factor / 2 - totalWidth * scale_factor / 2.8,(totalHeight / 2 - 100)*scale_factor,totalWidth * scale_factor / 20,"Pick a character!","black")
        drawAnimImg(playerSpriteSheet,3,.4,mario_x,char_y,34,1,16,16,64,64);
        drawAnimImg(playerSpriteSheet,3,.4,luigi_x,char_y,34,1 + 148,16,16,64,64);
        drawAnimImg(playerSpriteSheet,3,.4,toad_x,char_y,34,1 + 295,16,16,64,64);

        // See if any player is being clicked on and create that player
        let dx_mario = abs(mouse.x*scale_factor - mario_x - 32)
        let dx_luigi = abs(mouse.x*scale_factor - luigi_x - 32)
        let dx_toad = abs(mouse.x*scale_factor - toad_x - 32)
        let dy = abs(mouse.y*scale_factor - char_y - 32);
        if (dy < 32 && mouse.left) {
          if (dx_mario < 32) {
            gameState = 1;
            player1 = new Player(0,2,0);
            loopSound(musicUrl,.3);
          } else if (dx_luigi < 32) {
            gameState = 1;
            player1 = new Player(0,2,1);
            loopSound(musicUrl,.3);
          } else if (dx_toad < 32) {
            gameState = 1;
            player1 = new Player(0,2,2);
            loopSound(musicUrl,.3);
          }
        }
      }
    }
    
  </script>
</body>